"""Integration tests for vulnerability aggregator with disk caching."""
import os
import tempfile
from pathlib import Path
from unittest import mock

import pytest
import responses

from src.dependency_risk_profiler.models import DependencyMetadata
from src.dependency_risk_profiler.vulnerabilities.aggregator import (
    aggregate_vulnerability_data,
    OSVSource,
)
from src.dependency_risk_profiler.vulnerabilities.cache import VulnerabilityCache


@pytest.fixture
def mock_env_vars():
    """Fixture to set environment variables for testing."""
    # Store original values
    original_cache_disable = os.environ.get("DEPENDENCY_RISK_DISABLE_CACHE")
    original_cache_expiry = os.environ.get("DEPENDENCY_RISK_CACHE_EXPIRY")
    
    # Set test values
    os.environ["DEPENDENCY_RISK_DISABLE_CACHE"] = "0"
    os.environ["DEPENDENCY_RISK_CACHE_EXPIRY"] = "3600"
    
    yield
    
    # Restore original values
    if original_cache_disable is None:
        del os.environ["DEPENDENCY_RISK_DISABLE_CACHE"]
    else:
        os.environ["DEPENDENCY_RISK_DISABLE_CACHE"] = original_cache_disable
    
    if original_cache_expiry is None:
        del os.environ["DEPENDENCY_RISK_CACHE_EXPIRY"]
    else:
        os.environ["DEPENDENCY_RISK_CACHE_EXPIRY"] = original_cache_expiry


@pytest.fixture
def temp_cache_dir():
    """Create a temporary cache directory for testing."""
    with tempfile.TemporaryDirectory() as temp_dir:
        yield Path(temp_dir)


@pytest.fixture
def test_cache(temp_cache_dir):
    """Create a VulnerabilityCache instance for testing."""
    # Create a new cache instance
    cache_instance = VulnerabilityCache(cache_dir=temp_cache_dir)
    
    # Monkey patch the default cache instance for testing
    from src.dependency_risk_profiler.vulnerabilities import cache
    original_cache = cache.default_cache
    cache.default_cache = cache_instance
    
    yield cache_instance
    
    # Restore original cache
    cache.default_cache = original_cache


@pytest.fixture
def sample_vulnerability_data():
    """Sample vulnerability data for testing."""
    return [
        {
            "id": "CVE-2021-12345",
            "source": "OSV",
            "published": "2021-01-01T00:00:00Z",
            "summary": "Test vulnerability",
            "details": "This is a test vulnerability",
            "severity": "HIGH",
            "cvss_score": 7.5,
            "fixed_versions": ["1.2.3"],
            "references": ["https://example.com/vuln"]
        }
    ]


@pytest.fixture
def sample_dependency():
    """Sample dependency metadata for testing."""
    return DependencyMetadata(
        name="test-package",
        installed_version="1.0.0",
        repository_url="https://github.com/test/test-package"
    )


@pytest.fixture(autouse=True)
def reset_responses():
    """Reset responses after each test."""
    responses.reset()

def setup_mocks():
    """Set up mocks for vulnerability APIs."""
    # Set up OSV API mock response
    osv_url = "https://api.osv.dev/v1/query"
    responses.add(
        responses.POST,
        osv_url,
        json={"vulns": [
            {
                "id": "CVE-2021-12345",
                "summary": "Test vulnerability",
                "details": "This is a test vulnerability",
                "published": "2021-01-01T00:00:00Z",
                "references": [{"url": "https://example.com/vuln"}],
                "severity": [{"type": "CVSS_V3", "score": 7.5}],
                "affected": [
                    {
                        "package": {"name": "test-package", "ecosystem": "PyPI"},
                        "ranges": [
                            {
                                "type": "SEMVER",
                                "events": [
                                    {"introduced": "0"},
                                    {"fixed": "1.2.3"}
                                ]
                            }
                        ]
                    }
                ]
            }
        ]},
        status=200
    )
    
    # Set up NVD API mock response
    nvd_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
    responses.add(
        responses.GET,
        nvd_url,
        json={"vulnerabilities": []},
        status=200
    )

@responses.activate
def test_aggregator_with_disk_cache(mock_env_vars, test_cache, sample_dependency, sample_vulnerability_data):
    """Test that vulnerability data is cached to disk and reused."""
    # Setup mocks
    setup_mocks()
    
    # First call should make a network request
    with mock.patch("src.dependency_risk_profiler.vulnerabilities.aggregator.USE_DISK_CACHE", True):
        # Make sure the cache is empty
        test_cache.clear()
        dep, vulns = aggregate_vulnerability_data(sample_dependency)
    
    # Should have at least one network request
    assert len(responses.calls) > 0
    
    # Verify the results include our mocked vulnerability
    assert any(v["id"] == "CVE-2021-12345" for v in vulns)
    
    # Record the number of calls made
    first_call_count = len(responses.calls)
    
    # Second call should use the cache
    with mock.patch("src.dependency_risk_profiler.vulnerabilities.aggregator.USE_DISK_CACHE", True):
        dep2, vulns2 = aggregate_vulnerability_data(sample_dependency)
    
    # Verify no additional network requests were made
    assert len(responses.calls) == first_call_count
    
    # Verify the results are the same
    assert len(vulns) == len(vulns2)
    assert any(v["id"] == "CVE-2021-12345" for v in vulns2)
    
    # Verify cache was created
    assert len(list(test_cache.cache_dir.glob("*.json"))) > 0


@responses.activate
def test_aggregator_with_disabled_cache(mock_env_vars, test_cache, sample_dependency):
    """Test that disabling the cache forces network requests."""
    # Setup mocks
    setup_mocks()
    
    # Create cache entry first
    with mock.patch("src.dependency_risk_profiler.vulnerabilities.aggregator.USE_DISK_CACHE", True):
        # Make sure the cache is empty
        test_cache.clear()
        aggregate_vulnerability_data(sample_dependency)
    
    # Record the number of calls made
    first_call_count = len(responses.calls)
    assert first_call_count > 0
    
    # Now make a second call with the cache disabled
    with mock.patch("src.dependency_risk_profiler.vulnerabilities.aggregator.USE_DISK_CACHE", True), \
         mock.patch("src.dependency_risk_profiler.vulnerabilities.aggregator.os.environ", {"DEPENDENCY_RISK_DISABLE_CACHE": "1"}):
        # This should bypass the cache and make new requests
        aggregate_vulnerability_data(sample_dependency)
    
    # Verify additional network requests were made
    assert len(responses.calls) > first_call_count